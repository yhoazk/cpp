# [Export Maps](https://accu.org/index.php/journals/1372)

When exporting symbols froma shared library, the GNU ELF shared library
linker behaves in a significantly different way to the MS linker.
On windows, **nothing** is exported from a DLL unless the programmer
explicitly requests it. The GNU ELF linker, on the other hand, exports
**everything** by default.


GNU ELF makes initial development simpler, but there's a cost for that
simplicity, a C++ shared library will tipically contain a large number of
symbols. When an application is linked against that library, the compiler and
the linker generate a referene for each of those symbols, when the library is
loaded at run time, each reference has to be bound to the corresponding symbol
in the shared library.


When generating the library:
```
> g++ -shared -fPIC spaceship.cpp -o
libspaceship.so.1 -Wl,-soname=libspaceship.so.1
> ln -s libspaceship.so.1 libspaceship.so
> g++ testflight.cpp -L. -lspaceship -o testflight
> export LD_DEBUG=symbols
> export LD_LIBRARY_PATH=.
> ./testflight   
```

A total of 21 symbols from a relative small amount of code, and each one of the
symbols is bind by a string compare against every exported symbol in every
included library until a match is found.  So the number of symbols exported from
our library affects not just how many symbols have to be fixed up the the
executable, but how many strings matches have to be done for each binding.

Notice that even when we did not explicitly exported any symbol there are quite
a lot of symbols from STL instantiations being looked up.

To check what is being expoted we can use `nm`:
```
$ nm -g -D -C --defined-only libspaceship.so.1  
```

A a few ways to control what symbols are being included in the `so` file
generated by the GNU compiler. One way is to decorate the code with

```
__attribute__ (visibility("xxxx"))
```

Where xxx is the tag.


Other, introduced in GCC 4.0 uses the
```
#pragma GCC visibility
```

The last version is a script version. This helps to keep the code clean and
removes tool-chain dependencies.

#### `export maps`

The export maps are simple text files listing which symbols should be exported
and which should not.  This is true for C, but for C++ the situation is more
complicated.

For our example, this is the export map:
```
{
  global:
    extern "C++" {
      *scifi::Spaceship;
      scifi::Spaceship::Spaceship*;
      scifi::Spaceship::?Spaceship*;
      scifi::Spaceship::stabliseIonFluxers*;
      scifi::Spaceship::initiateHyperwarp*
    };
  local
    *;
};    
```

- - -
Related tools:
* `ldd`

* `so` libraries are loaded in order, then if a `so` contains an object with a
matching name the loader will use that symbol.
* Cheshire cat or abstract base classes.
